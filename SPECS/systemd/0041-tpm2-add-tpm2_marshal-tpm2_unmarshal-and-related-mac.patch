From 84cd873ca3e4664370e096c775c8546b937f9a24 Mon Sep 17 00:00:00 2001
From: Dan Streetman <ddstreet@ieee.org>
Date: Sat, 7 Jan 2023 07:18:16 -0500
Subject: [PATCH 41/44] tpm2: add tpm2_marshal(), tpm2_unmarshal(), and related
 macros

Add macros to simplify marshalling/unmarshalling of tpm objects.

Since each marshalling macro calls dlopen_tpm2(), also add check in
dlopen_tpm2() to exit early if all libraries are already loaded.
---
 src/shared/tpm2-util.c | 360 +++++++++++++++--------------------------
 src/shared/tpm2-util.h | 174 ++++++++++++++++++++
 2 files changed, 307 insertions(+), 227 deletions(-)

diff --git a/src/shared/tpm2-util.c b/src/shared/tpm2-util.c
index d4a3bd555f..a3ccf7f1cc 100644
--- a/src/shared/tpm2-util.c
+++ b/src/shared/tpm2-util.c
@@ -34,6 +34,10 @@ static void *libtss2_esys_dl = NULL;
 static void *libtss2_rc_dl = NULL;
 static void *libtss2_mu_dl = NULL;
 
+static bool is_dlopened(void) {
+        return libtss2_esys_dl && libtss2_rc_dl && libtss2_mu_dl;
+}
+
 static TSS2_RC (*sym_Esys_Create)(ESYS_CONTEXT *esysContext, ESYS_TR parentHandle, ESYS_TR shandle1, ESYS_TR shandle2, ESYS_TR shandle3, const TPM2B_SENSITIVE_CREATE *inSensitive, const TPM2B_PUBLIC *inPublic, const TPM2B_DATA *outsideInfo, const TPML_PCR_SELECTION *creationPCR, TPM2B_PRIVATE **outPrivate, TPM2B_PUBLIC **outPublic, TPM2B_CREATION_DATA **creationData, TPM2B_DIGEST **creationHash, TPMT_TK_CREATION **creationTicket) = NULL;
 static TSS2_RC (*sym_Esys_CreateLoaded)(ESYS_CONTEXT *esysContext, ESYS_TR parentHandle, ESYS_TR shandle1, ESYS_TR shandle2, ESYS_TR shandle3, const TPM2B_SENSITIVE_CREATE *inSensitive, const TPM2B_TEMPLATE *inPublic, ESYS_TR *objectHandle, TPM2B_PRIVATE **outPrivate, TPM2B_PUBLIC **outPublic) = NULL;
 static TSS2_RC (*sym_Esys_CreatePrimary)(ESYS_CONTEXT *esysContext, ESYS_TR primaryHandle, ESYS_TR shandle1, ESYS_TR shandle2, ESYS_TR shandle3, const TPM2B_SENSITIVE_CREATE *inSensitive, const TPM2B_PUBLIC *inPublic, const TPM2B_DATA *outsideInfo, const TPML_PCR_SELECTION *creationPCR, ESYS_TR *objectHandle, TPM2B_PUBLIC **outPublic, TPM2B_CREATION_DATA **creationData, TPM2B_DIGEST **creationHash, TPMT_TK_CREATION **creationTicket) = NULL;
@@ -69,28 +73,40 @@ static TSS2_RC (*sym_Esys_TRSess_SetAttributes)(ESYS_CONTEXT *esysContext, ESYS_
 static TSS2_RC (*sym_Esys_Unseal)(ESYS_CONTEXT *esysContext, ESYS_TR itemHandle, ESYS_TR shandle1, ESYS_TR shandle2, ESYS_TR shandle3, TPM2B_SENSITIVE_DATA **outData) = NULL;
 static TSS2_RC (*sym_Esys_VerifySignature)(ESYS_CONTEXT *esysContext, ESYS_TR keyHandle, ESYS_TR shandle1, ESYS_TR shandle2, ESYS_TR shandle3, const TPM2B_DIGEST *digest, const TPMT_SIGNATURE *signature, TPMT_TK_VERIFIED **validation) = NULL;
 
-static TSS2_RC (*sym_Tss2_MU_TPM2_CC_Marshal)(TPM2_CC src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2_HANDLE_Marshal)(TPM2_HANDLE src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_DIGEST_Marshal)(TPM2B_DIGEST const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_ENCRYPTED_SECRET_Marshal)(TPM2B_ENCRYPTED_SECRET const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_ENCRYPTED_SECRET_Unmarshal)(uint8_t const buffer[], size_t buffer_size, size_t *offset, TPM2B_ENCRYPTED_SECRET *dest) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_NAME_Marshal)(TPM2B_NAME const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_PRIVATE_Marshal)(TPM2B_PRIVATE const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_PRIVATE_Unmarshal)(uint8_t const buffer[], size_t buffer_size, size_t *offset, TPM2B_PRIVATE  *dest) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_PUBLIC_Marshal)(TPM2B_PUBLIC const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_PUBLIC_Unmarshal)(uint8_t const buffer[], size_t buffer_size, size_t *offset, TPM2B_PUBLIC *dest) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPM2B_SENSITIVE_Marshal)(TPM2B_SENSITIVE const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPML_PCR_SELECTION_Marshal)(TPML_PCR_SELECTION const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPMS_ECC_POINT_Marshal)(TPMS_ECC_POINT const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPMT_HA_Marshal)(TPMT_HA const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_TPMT_PUBLIC_Marshal)(TPMT_PUBLIC const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-static TSS2_RC (*sym_Tss2_MU_UINT32_Marshal)(UINT32 src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL;
-
-static const char* (*sym_Tss2_RC_Decode)(TSS2_RC rc) = NULL;
+#define DEFINE_MU(TYPE)                                                 \
+        TSS2_RC (*sym_Tss2_MU_##TYPE##_Marshal)(TYPE const *src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL; \
+        TSS2_RC (*sym_Tss2_MU_##TYPE##_Unmarshal)(uint8_t const buffer[], size_t buffer_size, size_t *offset, TYPE *dest) = NULL
+
+DEFINE_MU(TPM2B_DIGEST);
+DEFINE_MU(TPM2B_ENCRYPTED_SECRET);
+DEFINE_MU(TPM2B_NAME);
+DEFINE_MU(TPM2B_PRIVATE);
+DEFINE_MU(TPM2B_PUBLIC);
+DEFINE_MU(TPM2B_SENSITIVE);
+DEFINE_MU(TPML_PCR_SELECTION);
+DEFINE_MU(TPMS_ECC_POINT);
+DEFINE_MU(TPMT_HA);
+DEFINE_MU(TPMT_PUBLIC);
+
+#define DEFINE_MU_UINT(SIZE)                                            \
+        TSS2_RC (*sym_Tss2_MU_UINT##SIZE##_Marshal)(UINT##SIZE src, uint8_t buffer[], size_t buffer_size, size_t *offset) = NULL; \
+        TSS2_RC (*sym_Tss2_MU_UINT##SIZE##_Unmarshal)(uint8_t const buffer[], size_t buffer_size, size_t *offset, UINT##SIZE *dest) = NULL
+
+DEFINE_MU_UINT(8);
+DEFINE_MU_UINT(16);
+DEFINE_MU_UINT(32);
+DEFINE_MU_UINT(64);
+
+#define TPM2_MU_DLSYM_ARGS(TYPE) DLSYM_ARG(Tss2_MU_##TYPE##_Marshal), DLSYM_ARG(Tss2_MU_##TYPE##_Unmarshal)
+
+const char* (*sym_Tss2_RC_Decode)(TSS2_RC rc) = NULL;
 
 int dlopen_tpm2(void) {
         int r;
 
+        if (is_dlopened())
+                return 0;
+
         r = dlopen_many_sym_or_warn(
                         &libtss2_esys_dl, "libtss2-esys.so.0", LOG_DEBUG,
                         DLSYM_ARG(Esys_Create),
@@ -143,22 +159,20 @@ int dlopen_tpm2(void) {
 
         return dlopen_many_sym_or_warn(
                         &libtss2_mu_dl, "libtss2-mu.so.0", LOG_DEBUG,
-                        DLSYM_ARG(Tss2_MU_TPM2_CC_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPM2_HANDLE_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_DIGEST_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_ENCRYPTED_SECRET_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_ENCRYPTED_SECRET_Unmarshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_NAME_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_PRIVATE_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_PRIVATE_Unmarshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_PUBLIC_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_PUBLIC_Unmarshal),
-                        DLSYM_ARG(Tss2_MU_TPM2B_SENSITIVE_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPML_PCR_SELECTION_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPMS_ECC_POINT_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPMT_HA_Marshal),
-                        DLSYM_ARG(Tss2_MU_TPMT_PUBLIC_Marshal),
-                        DLSYM_ARG(Tss2_MU_UINT32_Marshal));
+                        TPM2_MU_DLSYM_ARGS(TPM2B_DIGEST),
+                        TPM2_MU_DLSYM_ARGS(TPM2B_ENCRYPTED_SECRET),
+                        TPM2_MU_DLSYM_ARGS(TPM2B_NAME),
+                        TPM2_MU_DLSYM_ARGS(TPM2B_PRIVATE),
+                        TPM2_MU_DLSYM_ARGS(TPM2B_PUBLIC),
+                        TPM2_MU_DLSYM_ARGS(TPM2B_SENSITIVE),
+                        TPM2_MU_DLSYM_ARGS(TPML_PCR_SELECTION),
+                        TPM2_MU_DLSYM_ARGS(TPMS_ECC_POINT),
+                        TPM2_MU_DLSYM_ARGS(TPMT_HA),
+                        TPM2_MU_DLSYM_ARGS(TPMT_PUBLIC),
+                        TPM2_MU_DLSYM_ARGS(UINT8),
+                        TPM2_MU_DLSYM_ARGS(UINT16),
+                        TPM2_MU_DLSYM_ARGS(UINT32),
+                        TPM2_MU_DLSYM_ARGS(UINT64));
 }
 
 static inline void Esys_Freep(void *p) {
@@ -2200,18 +2214,14 @@ static int _tpm2_create_loaded(
         TPMT_PUBLIC template_copy = *template;
         zero(template_copy.unique);
 
-        TPM2B_TEMPLATE tpm2b_template;
-        size_t size = 0;
-        rc = sym_Tss2_MU_TPMT_PUBLIC_Marshal(
+        TPM2B_TEMPLATE tpm2b_template = {};
+        r = tpm2_marshal(
+                        "public key template",
                         &template_copy,
                         tpm2b_template.buffer,
                         sizeof(tpm2b_template.buffer),
-                        &size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal public key template: %s", sym_Tss2_RC_Decode(rc));
-        assert(size <= UINT16_MAX);
-        tpm2b_template.size = size;
+                        0,
+                        &tpm2b_template.size);
 
         TPM2B_SENSITIVE_CREATE tpm2b_sensitive;
         if (sensitive)
@@ -3165,16 +3175,11 @@ static int find_signature(
  * Since we (currently) hardcode to always using SHA256 for hashing, this returns an error if the public key
  * nameAlg is not TPM2_ALG_SHA256. */
 int tpm2_calculate_name(const TPMT_PUBLIC *public, TPM2B_NAME *ret_name) {
-        TSS2_RC rc;
         int r;
 
         assert(public);
         assert(ret_name);
 
-        r = dlopen_tpm2();
-        if (r < 0)
-                return log_error_errno(r, "TPM2 support not installed: %m");
-
         if (public->nameAlg != TPM2_ALG_SHA256)
                 return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP),
                                        "Unsupported nameAlg: 0x%x",
@@ -3182,15 +3187,9 @@ int tpm2_calculate_name(const TPMT_PUBLIC *public, TPM2B_NAME *ret_name) {
 
         _cleanup_free_ uint8_t *buf = NULL;
         size_t size = 0;
-
-        buf = (uint8_t*) new(TPMT_PUBLIC, 1);
-        if (!buf)
-                return log_oom();
-
-        rc = sym_Tss2_MU_TPMT_PUBLIC_Marshal(public, buf, sizeof(TPMT_PUBLIC), &size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal public key: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_marshal_realloc("public key", public, buf, 0, &size);
+        if (r < 0)
+                return r;
 
         TPM2B_DIGEST digest = {};
         r = tpm2_digest_buffer(TPM2_ALG_SHA256, &digest, buf, size, /* extend= */ false);
@@ -3203,13 +3202,10 @@ int tpm2_calculate_name(const TPMT_PUBLIC *public, TPM2B_NAME *ret_name) {
         assert(digest.size <= sizeof(ha.digest.sha256));
         memcpy_safe(ha.digest.sha256, digest.buffer, digest.size);
 
-        TPM2B_NAME name;
-        size = 0;
-        rc = sym_Tss2_MU_TPMT_HA_Marshal(&ha, name.name, sizeof(name.name), &size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal key name: %s", sym_Tss2_RC_Decode(rc));
-        name.size = size;
+        TPM2B_NAME name = {};
+        r = tpm2_marshal("key name", &ha, name.name, sizeof(name.name), 0, &name.size);
+        if (r < 0)
+                return r;
 
         tpm2_log_debug_name(&name, "Calculated name");
 
@@ -3251,29 +3247,18 @@ static int tpm2_get_name(
 /* Extend 'digest' with the PolicyAuthValue calculated hash. */
 int tpm2_calculate_policy_auth_value(TPM2B_DIGEST *digest) {
         TPM2_CC command = TPM2_CC_PolicyAuthValue;
-        TSS2_RC rc;
         int r;
 
         assert(digest);
         assert(digest->size == SHA256_DIGEST_SIZE);
 
-        r = dlopen_tpm2();
+        _cleanup_free_ uint8_t *buf = NULL;
+        size_t size = 0;
+        r = tpm2_marshal_realloc("PolicyAuthValue command", command, buf, 0, &size);
         if (r < 0)
-                return log_error_errno(r, "TPM2 support not installed: %m");
-
-        uint8_t buf[sizeof(command)];
-        size_t offset = 0;
-
-        rc = sym_Tss2_MU_TPM2_CC_Marshal(command, buf, sizeof(buf), &offset);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal PolicyAuthValue command: %s", sym_Tss2_RC_Decode(rc));
-
-        if (offset != sizeof(command))
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Offset 0x%zx wrong after marshalling PolicyAuthValue command", offset);
+                return r;
 
-        r = tpm2_digest_buffer(TPM2_ALG_SHA256, digest, buf, offset, /* extend= */ true);
+        r = tpm2_digest_buffer(TPM2_ALG_SHA256, digest, buf, size, /* extend= */ true);
         if (r < 0)
                 return r;
 
@@ -3315,17 +3300,12 @@ int tpm2_calculate_policy_pcr(
                 TPM2B_DIGEST *digest) {
 
         TPM2_CC command = TPM2_CC_PolicyPCR;
-        TSS2_RC rc;
         int r;
 
         assert(pcr_values || n_pcr_values == 0);
         assert(digest);
         assert(digest->size == SHA256_DIGEST_SIZE);
 
-        r = dlopen_tpm2();
-        if (r < 0)
-                return log_error_errno(r, "TPM2 support not installed: %m");
-
         TPML_PCR_SELECTION pcr_selection;
         _cleanup_free_ TPM2B_DIGEST *values = NULL;
         size_t n_values;
@@ -3339,21 +3319,14 @@ int tpm2_calculate_policy_pcr(
                 return r;
 
         _cleanup_free_ uint8_t *buf = NULL;
-        size_t size = 0, maxsize = sizeof(command) + sizeof(pcr_selection);
-
-        buf = malloc(maxsize);
-        if (!buf)
-                return log_oom();
-
-        rc = sym_Tss2_MU_TPM2_CC_Marshal(command, buf, maxsize, &size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal PolicyPCR command: %s", sym_Tss2_RC_Decode(rc));
+        size_t size = 0;
+        r = tpm2_marshal_realloc("PolicyPCR command", command, buf, 0, &size);
+        if (r < 0)
+                return r;
 
-        rc = sym_Tss2_MU_TPML_PCR_SELECTION_Marshal(&pcr_selection, buf, maxsize, &size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal PCR selection: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_marshal_realloc("PCR selection", &pcr_selection, buf, size, &size);
+        if (r < 0)
+                return r;
 
         struct iovec data[] = {
                 IOVEC_MAKE(buf, size),
@@ -3404,28 +3377,17 @@ int tpm2_calculate_policy_authorize(
                 TPM2B_DIGEST *digest) {
 
         TPM2_CC command = TPM2_CC_PolicyAuthorize;
-        TSS2_RC rc;
         int r;
 
         assert(public);
         assert(digest);
         assert(digest->size == SHA256_DIGEST_SIZE);
 
-        r = dlopen_tpm2();
+        _cleanup_free_ uint8_t *buf = NULL;
+        size_t size = 0;
+        r = tpm2_marshal_realloc("PolicyAuthorize command", command, buf, 0, &size);
         if (r < 0)
-                return log_error_errno(r, "TPM2 support not installed: %m");
-
-        uint8_t buf[sizeof(command)];
-        size_t offset = 0;
-
-        rc = sym_Tss2_MU_TPM2_CC_Marshal(command, buf, sizeof(buf), &offset);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal PolicyAuthorize command: %s", sym_Tss2_RC_Decode(rc));
-
-        if (offset != sizeof(command))
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Offset 0x%zx wrong after marshalling PolicyAuthorize command", offset);
+                return r;
 
         TPM2B_NAME name = {};
         r = tpm2_calculate_name(&public->publicArea, &name);
@@ -3436,7 +3398,7 @@ int tpm2_calculate_policy_authorize(
         zero(digest->buffer);
 
         struct iovec data[] = {
-                IOVEC_MAKE(buf, offset),
+                IOVEC_MAKE(buf, size),
                 IOVEC_MAKE(name.name, name.size),
         };
         r = tpm2_digest_many(TPM2_ALG_SHA256, digest, data, ELEMENTSOF(data), /* extend= */ true);
@@ -3880,41 +3842,31 @@ int tpm2_create_blob(
                 void **ret_blob,
                 size_t *ret_blob_size) {
 
-        TSS2_RC rc;
+        int r;
 
         assert(public);
         assert(private);
         assert(ret_blob);
         assert(ret_blob_size);
 
-        size_t max_size = sizeof(*private) + sizeof(*public);
-        if (seed)
-                max_size += sizeof(*seed);
-
-        _cleanup_free_ void *blob = malloc(max_size);
-        if (!blob)
-                return log_oom_debug();
-
-        size_t blob_size = 0;
-        rc = sym_Tss2_MU_TPM2B_PRIVATE_Marshal(private, blob, max_size, &blob_size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal private key: %s", sym_Tss2_RC_Decode(rc));
+        _cleanup_free_ void *buf = NULL;
+        size_t size = 0;
+        r = tpm2_marshal_realloc("private key", private, buf, 0, &size);
+        if (r < 0)
+                return r;
 
-        rc = sym_Tss2_MU_TPM2B_PUBLIC_Marshal(public, blob, max_size, &blob_size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal public key: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_marshal_realloc("public key", public, buf, size, &size);
+        if (r < 0)
+                return r;
 
         if (seed) {
-                rc = sym_Tss2_MU_TPM2B_ENCRYPTED_SECRET_Marshal(seed, blob, max_size, &blob_size);
-                if (rc != TSS2_RC_SUCCESS)
-                        return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                               "Failed to marshal encrypted seed: %s", sym_Tss2_RC_Decode(rc));
+                r = tpm2_marshal_realloc("encrypted seed", seed, buf, size, &size);
+                if (r < 0)
+                        return r;
         }
 
-        *ret_blob = TAKE_PTR(blob);
-        *ret_blob_size = blob_size;
+        *ret_blob = TAKE_PTR(buf);
+        *ret_blob_size = size;
 
         return 0;
 }
@@ -3926,7 +3878,7 @@ int tpm2_extract_blob(
                 TPM2B_PRIVATE *ret_private,
                 TPM2B_ENCRYPTED_SECRET *ret_seed) {
 
-        TSS2_RC rc;
+        int r;
 
         assert(blob);
         assert(ret_public);
@@ -3935,23 +3887,20 @@ int tpm2_extract_blob(
 
         TPM2B_PRIVATE private = {};
         size_t offset = 0;
-        rc = sym_Tss2_MU_TPM2B_PRIVATE_Unmarshal(blob, blob_size, &offset, &private);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to unmarshal private key: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_unmarshal("private key", &private, blob, blob_size, offset, &offset);
+        if (r < 0)
+                return r;
 
         TPM2B_PUBLIC public = {};
-        rc = sym_Tss2_MU_TPM2B_PUBLIC_Unmarshal(blob, blob_size, &offset, &public);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to unmarshal public key: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_unmarshal("public key", &public, blob, blob_size, offset, &offset);
+        if (r < 0)
+                return r;
 
         TPM2B_ENCRYPTED_SECRET seed = {};
         if (blob_size > offset) {
-                rc = sym_Tss2_MU_TPM2B_ENCRYPTED_SECRET_Unmarshal(blob, blob_size, &offset, &seed);
-                if (rc != TSS2_RC_SUCCESS)
-                        return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                               "Failed to unmarshal encrypted seed: %s", sym_Tss2_RC_Decode(rc));
+                r = tpm2_unmarshal("encrypted seed", &seed, blob, blob_size, offset, &offset);
+                if (r < 0)
+                        return r;
         }
 
         *ret_public = public;
@@ -3971,42 +3920,34 @@ static int tpm2_calculate_serialize(
                 void **ret_serialized,
                 size_t *ret_serialized_size) {
 
-        TSS2_RC rc;
+        int r;
 
         assert(name);
         assert(public);
         assert(ret_serialized);
         assert(ret_serialized_size);
 
-        size_t max_size = sizeof(TPM2_HANDLE) + sizeof(TPM2B_NAME) + sizeof(uint32_t) + sizeof(TPM2B_PUBLIC);
-        _cleanup_free_ void *serialized = malloc(max_size);
-        if (!serialized)
-                return log_oom();
-
-        size_t serialized_size = 0;
-        rc = sym_Tss2_MU_TPM2_HANDLE_Marshal(location, serialized, max_size, &serialized_size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal tpm handle: %s", sym_Tss2_RC_Decode(rc));
+        _cleanup_free_ void *buf = NULL;
+        size_t size = 0;
+        r = tpm2_marshal_realloc("tpm handle", location, buf, 0, &size);
+        if (r < 0)
+                return r;
 
-        rc = sym_Tss2_MU_TPM2B_NAME_Marshal(name, serialized, max_size, &serialized_size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal name: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_marshal_realloc("name", name, buf, size, &size);
+        if (r < 0)
+                return r;
 
         /* This is defined (non-publicly) in the tpm2-tss source as IESYSC_KEY_RSRC, to a value of "1". */
-        rc = sym_Tss2_MU_UINT32_Marshal(UINT32_C(1), serialized, max_size, &serialized_size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal esys resource id: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_marshal_realloc("esys resource id", (uint32_t) 1, buf, size, &size);
+        if (r < 0)
+                return r;
 
-        rc = sym_Tss2_MU_TPM2B_PUBLIC_Marshal(public, serialized, max_size, &serialized_size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal public: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_marshal_realloc("public", public, buf, size, &size);
+        if (r < 0)
+                return r;
 
-        *ret_serialized = TAKE_PTR(serialized);
-        *ret_serialized_size = serialized_size;
+        *ret_serialized = TAKE_PTR(buf);
+        *ret_serialized_size = size;
 
         return 0;
 }
@@ -4282,7 +4223,6 @@ static int tpm2_calculate_seal_private(
                 size_t secret_size,
                 TPM2B_PRIVATE *ret) {
 
-        TSS2_RC rc;
         int r;
 
         assert(parent);
@@ -4342,19 +4282,16 @@ static int tpm2_calculate_seal_private(
                 },
         };
 
-        _cleanup_free_ void *marshalled_sensitive = malloc(sizeof(sensitive));
-        if (!marshalled_sensitive)
-                return log_oom();
-
+        _cleanup_free_ void *marshalled_sensitive = NULL;
         size_t marshalled_sensitive_size = 0;
-        rc = sym_Tss2_MU_TPM2B_SENSITIVE_Marshal(
+        r = tpm2_marshal_realloc(
+                        "sensitive",
                         &sensitive,
                         marshalled_sensitive,
-                        sizeof(sensitive),
+                        /* offset= */ 0,
                         &marshalled_sensitive_size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal sensitive: %s", sym_Tss2_RC_Decode(rc));
+        if (r < 0)
+                return 0;
 
         _cleanup_free_ void *encrypted_sensitive = NULL;
         size_t encrypted_sensitive_size;
@@ -4365,7 +4302,7 @@ static int tpm2_calculate_seal_private(
                         /* iv= */ NULL,
                         /* n_iv= */ 0,
                         &IOVEC_MAKE((void*) marshalled_sensitive, marshalled_sensitive_size),
-                        1,
+                        /* n_data= */ 1,
                         &encrypted_sensitive,
                         &encrypted_sensitive_size);
         if (r < 0)
@@ -4394,23 +4331,12 @@ static int tpm2_calculate_seal_private(
         if (r < 0)
                 return log_error_errno(r, "HMAC failed: %m");
 
-        assert(hmac_size <= UINT16_MAX);
-        TPM2B_DIGEST outer_hmac = {
-                .size = hmac_size,
-        };
-        memcpy(outer_hmac.buffer, hmac_buffer, hmac_size);
+        TPM2B_DIGEST outer_hmac = TPM2B_DIGEST_MAKE(hmac_buffer, hmac_size);
 
         TPM2B_PRIVATE private = {};
-        size_t private_size = 0;
-        rc = sym_Tss2_MU_TPM2B_DIGEST_Marshal(
-                        &outer_hmac,
-                        private.buffer,
-                        sizeof(private.buffer),
-                        &private_size);
-        if (rc != TSS2_RC_SUCCESS)
-                return log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal digest: %s", sym_Tss2_RC_Decode(rc));
-        private.size = private_size;
+        r = tpm2_marshal("digest", &outer_hmac, private.buffer, sizeof(private.buffer), 0, &private.size);
+        if (r < 0)
+                return r;
 
         assert(sizeof(private.buffer) - private.size >= encrypted_sensitive_size);
         memcpy_safe(&private.buffer[private.size], encrypted_sensitive, encrypted_sensitive_size);
@@ -4489,7 +4415,6 @@ static int tpm2_calculate_seal_ecc_seed(
                 void **ret_encrypted_seed,
                 size_t *ret_encrypted_seed_size) {
 
-        TSS2_RC rc;
         int r;
 
         assert(parent);
@@ -4529,15 +4454,11 @@ static int tpm2_calculate_seal_ecc_seed(
                 return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE), "ECC point y too large.");
         memcpy(point.y.buffer, y, y_size);
 
-        _cleanup_free_ void *encrypted_seed = malloc(sizeof(point));
-        if (!encrypted_seed)
-                return log_oom_debug();
-
+        _cleanup_free_ void *encrypted_seed = NULL;
         size_t encrypted_seed_size = 0;
-        rc = sym_Tss2_MU_TPMS_ECC_POINT_Marshal(&point, encrypted_seed, sizeof(point), &encrypted_seed_size);
-        if (rc != TPM2_RC_SUCCESS)
-                return log_debug_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE),
-                                       "Failed to marshal ECC point: %s", sym_Tss2_RC_Decode(rc));
+        r = tpm2_marshal_realloc("ECC point", &point, encrypted_seed, 0, &encrypted_seed_size);
+        if (r < 0)
+                return r;
 
         size_t hash_size = tpm2_hash_alg_to_size(parent->publicArea.nameAlg);
         if (hash_size == 0)
@@ -4839,8 +4760,6 @@ int tpm2_seal(Tpm2Context *c,
         if (!secret)
                 return log_oom();
 
-        log_debug("Marshalling private and public part of HMAC key.");
-
         _cleanup_free_ void *blob = NULL;
         size_t blob_size;
         r = tpm2_create_blob(public, private, /* seed= */ NULL, &blob, &blob_size);
@@ -4915,10 +4834,6 @@ int tpm2_unseal(const char *device,
         assert(TPM2_PCR_MASK_VALID(hash_pcr_mask));
         assert(TPM2_PCR_MASK_VALID(pubkey_pcr_mask));
 
-        r = dlopen_tpm2();
-        if (r < 0)
-                return log_error_errno(r, "TPM2 support is not installed.");
-
         /* So here's what we do here: We connect to the TPM2 chip. As we do when sealing we generate a
          * "primary" key on the TPM2 chip, with the same parameters as well as a PCR-bound policy session.
          * Given we pass the same parameters, this will result in the same "primary" key, and same policy
@@ -5108,10 +5023,6 @@ int tpm2_list_devices(void) {
         _cleanup_closedir_ DIR *d = NULL;
         int r;
 
-        r = dlopen_tpm2();
-        if (r < 0)
-                return log_error_errno(r, "TPM2 support is not installed.");
-
         t = table_new("path", "device", "driver");
         if (!t)
                 return log_oom();
@@ -5182,11 +5093,6 @@ int tpm2_find_device_auto(
                 char **ret) {
 #if HAVE_TPM2
         _cleanup_closedir_ DIR *d = NULL;
-        int r;
-
-        r = dlopen_tpm2();
-        if (r < 0)
-                return log_error_errno(r, "TPM2 support is not installed.");
 
         d = opendir("/sys/class/tpmrm");
         if (!d) {
diff --git a/src/shared/tpm2-util.h b/src/shared/tpm2-util.h
index 22557db061..a715345c41 100644
--- a/src/shared/tpm2-util.h
+++ b/src/shared/tpm2-util.h
@@ -48,6 +48,13 @@ static inline bool TPM2_PCR_MASK_VALID(uint32_t pcr_mask) {
 
 int dlopen_tpm2(void);
 
+/* Calls dlopen_tpm2() and returns 0 on success, < 0 on error. Useful in "elvis operator" ternary checks. */
+static inline int tpm2_dlopen(void) {
+        int r = dlopen_tpm2();
+
+        return r < 0 ? r : 0;
+}
+
 typedef struct {
         unsigned n_ref;
 
@@ -250,6 +257,173 @@ int tpm2_tpm2b_public_to_fingerprint(const TPM2B_PUBLIC *public, void **ret_fing
                         0;                                              \
         })
 
+/* Marshal/unmarshal macros */
+
+/* Most types are defined like this */
+#define DEFINE_EXTERN_MU(TYPE)                                          \
+        extern TSS2_RC (*sym_Tss2_MU_##TYPE##_Marshal)(TYPE const *src, uint8_t buffer[], size_t buffer_size, size_t *offset); \
+        extern TSS2_RC (*sym_Tss2_MU_##TYPE##_Unmarshal)(uint8_t const buffer[], size_t buffer_size, size_t *offset, TYPE *dest)
+
+DEFINE_EXTERN_MU(TPM2B_DIGEST);
+DEFINE_EXTERN_MU(TPM2B_ENCRYPTED_SECRET);
+DEFINE_EXTERN_MU(TPM2B_NAME);
+DEFINE_EXTERN_MU(TPM2B_PRIVATE);
+DEFINE_EXTERN_MU(TPM2B_PUBLIC);
+DEFINE_EXTERN_MU(TPM2B_SENSITIVE);
+DEFINE_EXTERN_MU(TPML_PCR_SELECTION);
+DEFINE_EXTERN_MU(TPMS_ECC_POINT);
+DEFINE_EXTERN_MU(TPMT_HA);
+DEFINE_EXTERN_MU(TPMT_PUBLIC);
+
+/* Number types are defined like this; note that we only need the base UINT8-64 types; all others
+ * (e.g. TPM2_CC) are just typedefs of UINTs. */
+#define DEFINE_EXTERN_MU_UINT(SIZE)                                     \
+        extern TSS2_RC (*sym_Tss2_MU_UINT##SIZE##_Marshal)(UINT##SIZE src, uint8_t buffer[], size_t buffer_size, size_t *offset); \
+        extern TSS2_RC (*sym_Tss2_MU_UINT##SIZE##_Unmarshal)(uint8_t const buffer[], size_t buffer_size, size_t *offset, UINT##SIZE *dest)
+
+DEFINE_EXTERN_MU_UINT(8);
+DEFINE_EXTERN_MU_UINT(16);
+DEFINE_EXTERN_MU_UINT(32);
+DEFINE_EXTERN_MU_UINT(64);
+
+extern const char* (*sym_Tss2_RC_Decode)(TSS2_RC rc);
+
+#define _MARSHAL_MAPPING(TYPE) TYPE*: sym_Tss2_MU_##TYPE##_Marshal, const TYPE*: sym_Tss2_MU_##TYPE##_Marshal
+#define _MARSHAL_MAPPING_UINT(SIZE) UINT##SIZE: sym_Tss2_MU_UINT##SIZE##_Marshal
+#define _UNMARSHAL_MAPPING(TYPE) TYPE*: sym_Tss2_MU_##TYPE##_Unmarshal
+#define _UNMARSHAL_MAPPING_UINT(SIZE) UINT##SIZE*: sym_Tss2_MU_UINT##SIZE##_Unmarshal
+
+/* Generic mappings for marshal/unmarshal type->function. */
+#define _MARSHAL(src)                                                   \
+        _Generic(src,                                                   \
+                 _MARSHAL_MAPPING(TPM2B_DIGEST),                        \
+                 _MARSHAL_MAPPING(TPM2B_ENCRYPTED_SECRET),              \
+                 _MARSHAL_MAPPING(TPM2B_NAME),                          \
+                 _MARSHAL_MAPPING(TPM2B_PRIVATE),                       \
+                 _MARSHAL_MAPPING(TPM2B_PUBLIC),                        \
+                 _MARSHAL_MAPPING(TPM2B_SENSITIVE),                     \
+                 _MARSHAL_MAPPING(TPML_PCR_SELECTION),                  \
+                 _MARSHAL_MAPPING(TPMS_ECC_POINT),                      \
+                 _MARSHAL_MAPPING(TPMT_HA),                             \
+                 _MARSHAL_MAPPING(TPMT_PUBLIC),                         \
+                 _MARSHAL_MAPPING_UINT(8),                              \
+                 _MARSHAL_MAPPING_UINT(16),                             \
+                 _MARSHAL_MAPPING_UINT(32),                             \
+                 _MARSHAL_MAPPING_UINT(64))
+#define _UNMARSHAL(dst)                                                 \
+        _Generic(dst,                                                   \
+                 _UNMARSHAL_MAPPING(TPM2B_DIGEST),                      \
+                 _UNMARSHAL_MAPPING(TPM2B_ENCRYPTED_SECRET),            \
+                 _UNMARSHAL_MAPPING(TPM2B_NAME),                        \
+                 _UNMARSHAL_MAPPING(TPM2B_PRIVATE),                     \
+                 _UNMARSHAL_MAPPING(TPM2B_PUBLIC),                      \
+                 _UNMARSHAL_MAPPING(TPM2B_SENSITIVE),                   \
+                 _UNMARSHAL_MAPPING(TPML_PCR_SELECTION),                \
+                 _UNMARSHAL_MAPPING(TPMS_ECC_POINT),                    \
+                 _UNMARSHAL_MAPPING(TPMT_HA),                           \
+                 _UNMARSHAL_MAPPING(TPMT_PUBLIC),                       \
+                 _UNMARSHAL_MAPPING_UINT(8),                            \
+                 _UNMARSHAL_MAPPING_UINT(16),                           \
+                 _UNMARSHAL_MAPPING_UINT(32),                           \
+                 _UNMARSHAL_MAPPING_UINT(64))
+
+/* Helper macro to set ret_size unless it is NULL. Note that ret_size may be a pointer to any numeric
+ * type. Returns 0. */
+#define _tpm2_marshalling_update_ret_size(size, ret_size, u)            \
+        ({                                                              \
+                size_t UNIQ_T(S, u) = (size);                           \
+                typeof(__builtin_choose_expr(__builtin_types_compatible_p(typeof(ret_size), void*), &UNIQ_T(S, u), ret_size)) UNIQ_T(RET, u) = (ret_size); \
+                if (UNIQ_T(RET, u))                                     \
+                        *UNIQ_T(RET, u) = UNIQ_T(S, u);                 \
+                0;                                                      \
+        })
+
+/* Marshal src into buf, starting at offset. The size of buf is max. If succesful and ret_size is not NULL,
+ * it is set to offset plus the number of marshalled bytes. Returns 0 on success or < 0 on error. */
+#define tpm2_marshal(desc, src, buf, max, offset, ret_size)             \
+        (tpm2_dlopen() ?: _tpm2_marshal(desc, src, buf, max, offset, ret_size, UNIQ))
+#define _tpm2_marshal(desc, src, buf, max, offset, ret_size, u)         \
+        ({                                                              \
+                const char *UNIQ_T(DESC, u) = (desc);                   \
+                log_debug("Marshalling %s", UNIQ_T(DESC, u));           \
+                __tpm2_marshal(UNIQ_T(DESC, u), src, buf, max, offset, ret_size, u); \
+        })
+#define __tpm2_marshal(desc, src, buf, max, offset, ret_size, u)        \
+        ({                                                              \
+                size_t UNIQ_T(O, u) = (offset);                         \
+                TSS2_RC UNIQ_T(RC, u) = _MARSHAL(src)(src, buf, max, &UNIQ_T(O, u)); \
+                UNIQ_T(RC, u) == TSS2_RC_SUCCESS                        \
+                        ? _tpm2_marshalling_update_ret_size(UNIQ_T(O, u), (ret_size), CONCATENATE(u, __tpm2_marshal)) \
+                        : log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE), \
+                                          "Failed to marshal %s: %s",   \
+                                          desc, sym_Tss2_RC_Decode(UNIQ_T(RC, u))); \
+        })
+
+/* Similar to tpm2_marshal() but only calculates the size required for marshalling. ret_size cannot be
+ * NULL. Returns 0 if successful or < 0 on an error. */
+#define tpm2_marshal_size(desc, src, ret_size)                          \
+        (tpm2_dlopen() ?: _tpm2_marshal_size(desc, src, ret_size, UNIQ))
+#define _tpm2_marshal_size(desc, src, ret_size, u)                      \
+        ({                                                              \
+                const char *UNIQ_T(DESC, u) = (desc);                   \
+                size_t UNIQ_T(S, u);                                    \
+                __tpm2_marshal(UNIQ_T(DESC, u), src, NULL, SIZE_MAX, 0, &UNIQ_T(S, u), CONCATENATE(u, _tpm2_marshal_size)) \
+                        ? /* != 0 (failure) */                          \
+                        : ({                                            \
+                                        log_debug("Marshalling %s requires %zu bytes.", UNIQ_T(DESC, u), UNIQ_T(S, u)); \
+                                        _tpm2_marshalling_update_ret_size(UNIQ_T(S, u), (ret_size), CONCATENATE(u, __tpm2_marshal)); \
+                                });                                     \
+        })
+
+/* Similar to tpm2_marshal() but uses greedy_realloc() to append the marshalled data. The buf must be usable
+ * with greedy_realloc(). The value of buf (i.e. location of allocated memory) may be modified, so it must be
+ * an lvalue. Returns 0 if successful or < 0 on an error. */
+#define tpm2_marshal_realloc(desc, src, buf, offset, ret_size)          \
+        (tpm2_dlopen() ?: _tpm2_marshal_realloc(desc, src, buf, offset, ret_size, UNIQ))
+#define _tpm2_marshal_realloc(desc, src, buf, offset, ret_size, u)      \
+        ({                                                              \
+                const char *UNIQ_T(DESC, u) = (desc);                   \
+                typeof(src) UNIQ_T(SRC, u) = (src);                     \
+                void **UNIQ_T(BUF, u) = (void**) &(buf);                \
+                size_t UNIQ_T(O, u) = (offset);                         \
+                size_t UNIQ_T(S, u);                                    \
+                _tpm2_marshal_size(UNIQ_T(DESC, u), UNIQ_T(SRC, u), &UNIQ_T(S, u), CONCATENATE(u, _tpm2_marshal_realloc)) \
+                        ? /* != 0 (failure) */                          \
+                        : greedy_realloc(UNIQ_T(BUF, u), UNIQ_T(O, u) + UNIQ_T(S, u), 1) \
+                        ? _tpm2_marshal(UNIQ_T(DESC, u), UNIQ_T(SRC, u), *UNIQ_T(BUF, u), UNIQ_T(O, u) + UNIQ_T(S, u), UNIQ_T(O, u), (ret_size), CONCATENATE(u, _tpm2_marshal_realloc)) \
+                        : log_oom();                                    \
+        })
+
+/* Unmarshal data from buf, starting at offset, into dst. The size of buf is max. If successful and ret_size
+ * is not NULL, it is set to offset plus the number of unmarshalled bytes. Returns 0 on success or < 0 on
+ * error. */
+#define tpm2_unmarshal(desc, dst, buf, max, offset, ret_size)           \
+        (tpm2_dlopen() ?: _tpm2_unmarshal(desc, dst, buf, max, offset, ret_size, UNIQ))
+#define _tpm2_unmarshal(desc, dst, buf, max, offset, ret_size, u)       \
+        ({                                                              \
+                const char *UNIQ_T(DESC, u) = (desc);                   \
+                log_debug("Unmarshalling %s", UNIQ_T(DESC, u));         \
+                size_t UNIQ_T(O, u) = (offset);                         \
+                TSS2_RC UNIQ_T(RC, u) = _UNMARSHAL(dst)(buf, max, &UNIQ_T(O, u), dst); \
+                UNIQ_T(RC, u) == TSS2_RC_SUCCESS     \
+                        ? _tpm2_marshalling_update_ret_size(UNIQ_T(O, u), (ret_size), CONCATENATE(u, _tpm2_unmarshal)) \
+                        : log_error_errno(SYNTHETIC_ERRNO(ENOTRECOVERABLE), \
+                                          "Failed to unmarshal %s: %s", \
+                                          desc, sym_Tss2_RC_Decode(UNIQ_T(RC, u))); \
+        })
+
+#define tpm2_unmarshal_from_file(desc, dst, f, ret_size)                \
+        (tpm2_dlopen() ?: _tpm2_unmarshal_from_file(desc, dst, f, ret_size, UNIQ))
+#define _tpm2_unmarshal_from_file(desc, dst, f, ret_size, u)            \
+        ({                                                              \
+                _cleanup_free_ char *UNIQ_T(B, u) = NULL;               \
+                size_t UNIQ_T(S, u);                                    \
+                int UNIQ_T(R, u) = read_full_file(f, &UNIQ_T(B, u), &UNIQ_T(S, u)); \
+                if (UNIQ_T(R, u) >= 0)                                  \
+                        UNIQ_T(R, u) = _tpm2_unmarshal(desc, dst, (uint8_t*) UNIQ_T(B, u), UNIQ_T(S, u), 0, ret_size, CONCATENATE(u, _tpm2_unmarshal_from_file)); \
+                UNIQ_T(R, u);                                           \
+        })
+
 #else /* HAVE_TPM2 */
 typedef struct {} Tpm2Context;
 typedef struct {} Tpm2Handle;
-- 
2.34.1

